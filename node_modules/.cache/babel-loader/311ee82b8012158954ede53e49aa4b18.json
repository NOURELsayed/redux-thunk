{"ast":null,"code":"const Ajv = require(\"ajv\");\n\nconst ajv = new Ajv({\n  format: 'full',\n  allErrors: true,\n  jsonPointers: true\n});\n\nconst pointer = require('json-pointer');\n\nconst AJVErrorParser = require('ajv-error-parser');\n\nexport const validatorService = {\n  validateInput,\n  validateForm,\n  buildHumanErrors,\n  buildHumanErrorsWithoutSchema\n};\n\nfunction validateInput(schema, name, value) {\n  const obj = {\n    [name]: value\n  };\n  const inputSchema = {\n    \"properties\": {}\n  };\n  inputSchema.properties[name] = pointer.get(schema, '/properties/' + name);\n  const validate = ajv.compile(inputSchema);\n  const valid = validate(obj);\n  return valid ? null : validate.errors;\n}\n\nfunction validateForm(schema, data) {\n  const validate = ajv.compile(schema);\n  const valid = validate(data);\n  return valid ? null : validate.errors;\n}\n\nfunction buildHumanErrors(schema, errorsObj) {\n  const errors = {};\n\n  for (let error of errorsObj) {\n    const input = error.dataPath.replace('/', '');\n    const property = pointer.get(schema, '/properties' + error.dataPath);\n\n    if (error.params.missingProperty) {\n      errors[input] = property.title + ' is a required field';\n    } else if (error.keyword === 'format' && property.example) {\n      errors[input] = property.title + ' is in an invalid format, e.g: ' + property.example;\n    } else {\n      errors[input] = property.title + ' ' + error.message;\n    }\n  }\n\n  return errors;\n}\n\nfunction buildHumanErrorsWithoutSchema(errorsObj) {\n  return AJVErrorParser.parseErrors(errorsObj);\n}","map":{"version":3,"sources":["/media/norhan/New Volume/work/React-projects/test-redux/src/services/validator.service.js"],"names":["Ajv","require","ajv","format","allErrors","jsonPointers","pointer","AJVErrorParser","validatorService","validateInput","validateForm","buildHumanErrors","buildHumanErrorsWithoutSchema","schema","name","value","obj","inputSchema","properties","get","validate","compile","valid","errors","data","errorsObj","error","input","dataPath","replace","property","params","missingProperty","title","keyword","example","message","parseErrors"],"mappings":"AAAA,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAnB;;AACA,MAAMC,GAAG,GAAG,IAAIF,GAAJ,CAAQ;AAACG,EAAAA,MAAM,EAAE,MAAT;AAAiBC,EAAAA,SAAS,EAAE,IAA5B;AAAkCC,EAAAA,YAAY,EAAE;AAAhD,CAAR,CAAZ;;AACA,MAAMC,OAAO,GAAGL,OAAO,CAAC,cAAD,CAAvB;;AACA,MAAMM,cAAc,GAAGN,OAAO,CAAC,kBAAD,CAA9B;;AAEA,OAAO,MAAMO,gBAAgB,GAAG;AAC9BC,EAAAA,aAD8B;AAE9BC,EAAAA,YAF8B;AAG9BC,EAAAA,gBAH8B;AAI9BC,EAAAA;AAJ8B,CAAzB;;AAOP,SAASH,aAAT,CAAuBI,MAAvB,EAA+BC,IAA/B,EAAqCC,KAArC,EAA4C;AAC1C,QAAMC,GAAG,GAAG;AAAC,KAACF,IAAD,GAAQC;AAAT,GAAZ;AACA,QAAME,WAAW,GAAG;AAAC,kBAAc;AAAf,GAApB;AACAA,EAAAA,WAAW,CAACC,UAAZ,CAAuBJ,IAAvB,IAA+BR,OAAO,CAACa,GAAR,CAAYN,MAAZ,EAAoB,iBAAiBC,IAArC,CAA/B;AACA,QAAMM,QAAQ,GAAGlB,GAAG,CAACmB,OAAJ,CAAYJ,WAAZ,CAAjB;AACA,QAAMK,KAAK,GAAGF,QAAQ,CAACJ,GAAD,CAAtB;AACA,SAAOM,KAAK,GAAG,IAAH,GAAUF,QAAQ,CAACG,MAA/B;AACD;;AAED,SAASb,YAAT,CAAsBG,MAAtB,EAA8BW,IAA9B,EAAoC;AAClC,QAAMJ,QAAQ,GAAGlB,GAAG,CAACmB,OAAJ,CAAYR,MAAZ,CAAjB;AACA,QAAMS,KAAK,GAAGF,QAAQ,CAACI,IAAD,CAAtB;AACA,SAAOF,KAAK,GAAG,IAAH,GAAUF,QAAQ,CAACG,MAA/B;AACD;;AAED,SAASZ,gBAAT,CAA0BE,MAA1B,EAAkCY,SAAlC,EAA6C;AAC3C,QAAMF,MAAM,GAAG,EAAf;;AACA,OAAK,IAAIG,KAAT,IAAkBD,SAAlB,EAA6B;AAC3B,UAAME,KAAK,GAAGD,KAAK,CAACE,QAAN,CAAeC,OAAf,CAAuB,GAAvB,EAA4B,EAA5B,CAAd;AACA,UAAMC,QAAQ,GAAGxB,OAAO,CAACa,GAAR,CAAYN,MAAZ,EAAoB,gBAAgBa,KAAK,CAACE,QAA1C,CAAjB;;AACA,QAAIF,KAAK,CAACK,MAAN,CAAaC,eAAjB,EAAkC;AAChCT,MAAAA,MAAM,CAACI,KAAD,CAAN,GAAgBG,QAAQ,CAACG,KAAT,GAAiB,sBAAjC;AACD,KAFD,MAEO,IAAIP,KAAK,CAACQ,OAAN,KAAkB,QAAlB,IAA8BJ,QAAQ,CAACK,OAA3C,EAAoD;AACzDZ,MAAAA,MAAM,CAACI,KAAD,CAAN,GAAgBG,QAAQ,CAACG,KAAT,GAAiB,iCAAjB,GAAqDH,QAAQ,CAACK,OAA9E;AACD,KAFM,MAEA;AACLZ,MAAAA,MAAM,CAACI,KAAD,CAAN,GAAgBG,QAAQ,CAACG,KAAT,GAAiB,GAAjB,GAAuBP,KAAK,CAACU,OAA7C;AACD;AACF;;AACD,SAAOb,MAAP;AACD;;AAED,SAASX,6BAAT,CAAuCa,SAAvC,EAAkD;AAChD,SAAOlB,cAAc,CAAC8B,WAAf,CAA2BZ,SAA3B,CAAP;AACD","sourcesContent":["const Ajv = require(\"ajv\");\r\nconst ajv = new Ajv({format: 'full', allErrors: true, jsonPointers: true});\r\nconst pointer = require('json-pointer');\r\nconst AJVErrorParser = require('ajv-error-parser');\r\n\r\nexport const validatorService = {\r\n  validateInput,\r\n  validateForm,\r\n  buildHumanErrors,\r\n  buildHumanErrorsWithoutSchema\r\n};\r\n\r\nfunction validateInput(schema, name, value) {\r\n  const obj = {[name]: value};\r\n  const inputSchema = {\"properties\": {}};\r\n  inputSchema.properties[name] = pointer.get(schema, '/properties/' + name);\r\n  const validate = ajv.compile(inputSchema);\r\n  const valid = validate(obj);\r\n  return valid ? null : validate.errors;\r\n}\r\n\r\nfunction validateForm(schema, data) {\r\n  const validate = ajv.compile(schema);\r\n  const valid = validate(data);\r\n  return valid ? null : validate.errors;\r\n}\r\n\r\nfunction buildHumanErrors(schema, errorsObj) {\r\n  const errors = {};\r\n  for (let error of errorsObj) {\r\n    const input = error.dataPath.replace('/', '');\r\n    const property = pointer.get(schema, '/properties' + error.dataPath);\r\n    if (error.params.missingProperty) {\r\n      errors[input] = property.title + ' is a required field';\r\n    } else if (error.keyword === 'format' && property.example) {\r\n      errors[input] = property.title + ' is in an invalid format, e.g: ' + property.example;\r\n    } else {\r\n      errors[input] = property.title + ' ' + error.message;\r\n    }\r\n  }\r\n  return errors;\r\n}\r\n\r\nfunction buildHumanErrorsWithoutSchema(errorsObj) {\r\n  return AJVErrorParser.parseErrors(errorsObj);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}